#pragma config(Sensor, S1,     RightLight,          sensorLightActive)
#pragma config(Sensor, S2,     Touch,               sensorTouch)
#pragma config(Sensor, S4,     LeftLight,           sensorLightActive)
#pragma config(Motor,  motorA,          RightTire,     tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          LeftTire,      tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

This code is built upon the Grid Array code from my Schoolwork/CS323 repository.
It has most of the same constructs as that file with the addition of using a second
robot starting at opposite corners of the grid.  These robots communicate via bluetooth
and send their current location as well as where they are headed.  This data is used to
prevent each robot from visiting a square in the grid that has already been visited by
the other robot.
Author: Donovan Torgerson
Email: Donovan@Torgersonlabs.com

Directions:
00000001 = Down
00000010 = Right
00000100 = Up
00001000 = Left

128 64 32 16 8 4 2 1

*/

task WatchLight();
void NextSquare();

const int rowsize = 3;
const int columnsize = 3;
int RightRead = 100;
int LeftRead = 100;
int LeftSpeed= 20;
int RightSpeed= 20;
int MonitorTouch;
int dir = 0b00000001;
byte board[rowsize][columnsize];
int CurrentRow = 0;
int CurrentCol = 0;
int FutureRow = 1;
int FutureCol = 0;
int HisFutRow = 0;
int HisFutCol = 0;
int HisWin = 0;
bool BackOut = false;
bool Find = true;
bool Win = true;

task CheckQueue()
{
  while(true)
  {
    if (bQueuedMsgAvailable())
    {
      board[messageParm[0]][messageParm[1]] = messageParm[2];
      ClearMessage();
      wait1Msec(500);
    }
    if (bQueuedMsgAvailable())
    {
      HisFutRow = messageParm[0];
      HisFutCol = messageParm[1];
      HisWin = messageParm[2];
      ClearMessage();
      wait1Msec(500);
    }
  }
}

task SendInfo()
{
  while(true)
  {
    sendMessageWithParm(CurrentRow, CurrentCol, board[CurrentRow][CurrentCol]);
    wait1Msec(500);
    sendMessageWithParm(FutureRow, FutureCol, Win);
    wait1Msec(500);
  }
}

task WatchLight()
{
 while(true)
 {
  RightRead = SensorValue[RightLight];
  LeftRead = (SensorValue[LeftLight] - 2);
  nxtDisplayClearTextLine(4);
  nxtDisplayTextLine(4,"R Eye: %d L Eye: %d",RightRead,LeftRead);
  wait1Msec(90);
 }
}

task WatchTires()
{
 int leftrotation = 0;
 int rightrotation = 0;
 bool up = true;
  while(true)
  {
   leftrotation = nMotorEncoder[LeftTire];
   rightrotation = nMotorEncoder[RightTire];
   nxtDisplayTextLine(2,"L: %d",leftrotation);
   nxtDisplayTextLine(3,"R: %d",rightrotation);
   wait1Msec(100);
  }
}

task WatchTouch()
{
  while (true)
  {
    MonitorTouch = SensorValue[Touch];
    nxtDisplayClearTextLine(7);
    nxtDisplayTextLine(7,"Touch: %d",MonitorTouch);
    wait1Msec(100);
  }
}

task WatchDirection() // Display current direction.
{
  while (true)
  {
    if (dir == 0b00000001)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Down");
    }
    else if (dir == 0b00000010)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Right");
    }
    else if (dir == 0b00000100)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Up");
    }
    else if (dir == 0b00001000)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Left");
    }
  }
}

task DisplayLoc() // Display array location.
{
    while (true)
  {
    nxtDisplayClearTextLine(1);
    nxtDisplayClearTextLine(5);
    nxtDisplayTextLine(1,"r: %d c: %d",CurrentRow,CurrentCol);
    nxtDisplayTextLine(5,"fr: %d fc: %d",FutureRow,FutureCol);
    wait1Msec(100);
  }
}

void AdjustLeft()
{
  motor[RightTire] = -10;
  motor[LeftTire] = 20;
  while(RightRead < LeftRead);
  motor[RightTire] = 0;
  motor[LeftTire] = 0;
}

void AdjustRight()
{
  motor[RightTire] = 20;
  motor[LeftTire] = -10;
  while(LeftRead < RightRead);
  motor[RightTire] = 0;
  motor[LeftTire] = 0;
}

void CurrentLoc() // Calculate current location
{
  if (dir & 0b00000001)
  {
    CurrentRow += 1;
    FutureRow = CurrentRow + 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00000010)
  {
    CurrentCol += 1;
    FutureRow = CurrentRow;
    FutureCol = CurrentCol + 1;
  }
  else if (dir & 0b00000100)
  {
    CurrentRow -= 1;
    FutureRow = CurrentRow - 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00001000)
  {
    CurrentCol -= 1;
    FutureRow = CurrentRow;
    FutureCol = CurrentCol - 1;
  }
  if (FutureRow <0 || FutureCol <0)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
  if (FutureRow >= rowsize || FutureCol >= columnsize)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
}

void LocTurn() // Calculate direction after a turn.
{
  if (dir & 0b00000001)
  {
    FutureRow = CurrentRow + 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00000010)
  {
    FutureRow = CurrentRow;
    FutureCol = CurrentCol + 1;
  }
  else if (dir & 0b00000100)
  {
    FutureRow = CurrentRow - 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00001000)
  {
    FutureRow = CurrentRow;
    FutureCol = CurrentCol - 1;
  }
  if (FutureRow <0 || FutureCol <0)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
  if (FutureRow >= rowsize || FutureCol >= columnsize)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
}

void LeftTurn() // Left turn code
 {
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  nMotorEncoder[LeftTire] = 0;
  nMotorEncoder[RightTire] = 0;
  motor[LeftTire] = -20;
  motor[RightTire] = 20;
  while(nMotorEncoder[RightTire] < 520);
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  if (dir == 0b00001000)
  {
    dir = 0b00000001;
  }
  else
  {
    dir = dir << 1;
  }
  LocTurn();
 }

void RightTurn() // Right turn code
 {
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  nMotorEncoder[LeftTire] = 0;
  nMotorEncoder[RightTire] = 0;
  motor[LeftTire] = 20;
  motor[RightTire] = -20;
  while(nMotorEncoder[LeftTire] < 520);
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  nMotorEncoder[RightTire] = 0;
  nMotorEncoder[LeftTire] = 0;
  if (dir == 0b00000001)
    {
      dir = 0b00001000;
    }
  else
    {
      dir = dir >> 1;
    }
  LocTurn();
 }

void LineAdjust() // Adjust to line and check for wall.
  {
    bool go = true;
    while (go)
    {
	    motor[RightTire] = 20;
	    motor[LeftTire] = 20;
	    if (MonitorTouch > 0)
       {
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         nMotorEncoder[LeftTire] = 0;
         nMotorEncoder[RightTire] = 0;
         motor[RightTire] = -15;
         motor[LeftTire] = -15;
         while(nMotorEncoder[RightTire] > -200);
         nMotorEncoder[LeftTire] = 0;
         nMotorEncoder[RightTire] = 0;
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         board[CurrentRow][CurrentCol] ^= dir;
         wait1Msec(5000);
         go = false;
	      }
	    else if (RightRead < 43 || LeftRead < 43)
	    {
	     if (MonitorTouch > 0)
        {
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         wait1Msec(5000);
        }
	     else if (abs(RightRead - LeftRead) < 6)
	      {
	        motor[RightTire] = 0;
	        motor[LeftTire] = 0;
	        go = false;
	        wait1Msec(1000);
	        NextSquare();
	      }
	     else if (RightRead < (LeftRead - 6))
	      {
	        AdjustLeft();
	      }
	     else if (LeftRead < (RightRead - 6))
	      {
          AdjustRight();
        }
      }
    }
  }

void AdjBack()
{
    bool go = true;
    while (go)
    {
	    motor[RightTire] = 20;
	    motor[LeftTire] = 20;
	    if (RightRead < 43 || LeftRead < 43)
	    {
	     if (abs(RightRead - LeftRead) < 6)
	     {
	       motor[RightTire] = 0;
	       motor[LeftTire] = 0;
	       go = false;
	       wait1Msec(1000);
	       nMotorEncoder[LeftTire] = 0;
         nMotorEncoder[RightTire] = 0;
         motor[RightTire] = 20;
         motor[LeftTire] = 20;
         while(nMotorEncoder[RightTire] < 830);
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         CurrentLoc();
         BackOut = false;
	     }
	     else if (RightRead < (LeftRead - 6))
	     {
	       AdjustLeft();
	     }
	     else if (LeftRead < (RightRead - 6))
	     {
         AdjustRight();
       }
     }
   }
 }

void NextSquare() // Move to next square and run CurrentLoc.
{
  board[CurrentRow][CurrentCol] ^= dir;
  nMotorEncoder[LeftTire] = 0;
  nMotorEncoder[RightTire] = 0;
  motor[RightTire] = 20;
  motor[LeftTire] = 20;
  while(nMotorEncoder[RightTire] < 830);
  motor[RightTire] = 0;
  motor[LeftTire] = 0;
  if (RightRead < 43 || LeftRead < 43)
  {
    nVolume = 3;
    PlaySound(soundUpwardTones);
    RightTurn();
    RightTurn();
    nMotorEncoder[LeftTire] = 0;
    nMotorEncoder[RightTire] = 0;
    motor[RightTire] = 20;
    motor[LeftTire] = 20;
    while(nMotorEncoder[RightTire] < 830);
    motor[RightTire] = 0;
    motor[LeftTire] = 0;
    Find = false;
  }
  else
  {
    CurrentLoc();
    board[CurrentRow][CurrentCol] = board[CurrentRow][CurrentCol] | (dir <<4);
  }
  wait1Msec(2000);
}

task main()
{
  setBluetoothOn();
  while(nBTCurrentStreamIndex == -1);
  wait1Msec(1000);
  StartTask(WatchTires);
  wait1Msec(90);
  StartTask(WatchLight);
  wait1Msec(90);
  StartTask(WatchTouch);
  wait1Msec(90);
//  StartTask(WatchDirection);
//  wait1Msec(90);
  StartTask(DisplayLoc);
  wait1Msec(90);
  for (int r=0;r<rowsize;r++)
  {
    for (int c=0;c<columnsize;c++)
    {
      board[r][c] = 0b00001111;
      if (r==0) board[r][c]^=0b00000100;
      if (r==rowsize-1) board[r][c]^=0b00000001;
      if (c==0) board[r][c]^=0b00001000;
      if (c==columnsize-1) board[r][c]^=0b00000010;
    }
  }
  board[0][0] = board[0][0] | 0b11110000;
  StartTask(CheckQueue);
  StartTask(SendInfo);
//  LeftTurn();
//  motor[RightTire]=LeftSpeed;
//  motor[LeftTire]=RightSpeed;
//  board[CurrentRow][CurrentCol] = 0b00001000;
//  dir = 0b00001000;
  while(Find)
  {
    if (BackOut)
    {
      int IncDir = board[CurrentRow][CurrentCol] & 0b11110000;
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"IncDir: %d",IncDir);
      wait1Msec(100);
      if (IncDir==0b11110000) // Home Square; loss
      {
        nVolume = 3;
        PlaySound(soundLowBuzz);
        wait1Msec(1000);
        Find = false;
        Win = false;
      }
      else if (IncDir==0b00010000) // If entered down, leave up.
      {
        if (dir & 0b00000001) // If facing down, turn Right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 1x.
	      {
	        RightTurn();
	      }
      }
      else if (IncDir==0b00100000) // If entered right, leave left.
      {
        if (dir & 0b00000001) // If facing down, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, do nothing.
	      {
          AdjBack();
	      }
      }
      else if (IncDir==0b01000000) // If entered up, leave down.
      {
        if (dir & 0b00000001) // If facing down, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn left 1x.
	      {
	        LeftTurn();
	      }
      }
      else if (IncDir==0b10000000) // If entered left, leave right.
      {
        if (dir & 0b00000001) // If facing down, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
      }
    }
    else
    {
	    if (((board[CurrentRow][CurrentCol] & dir) >0)&&((board[FutureRow][FutureCol] & 0b11110000)==0))
	    {
	      LineAdjust();
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00000001) >0)&&((board[CurrentRow +1][CurrentCol] & 0b11110000)==0)) // Down
	    {
	      if (dir & 0b00000001) // If facing down, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn left 1x.
	      {
	        LeftTurn();
	      }
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00000010) >0)&&((board[CurrentRow][CurrentCol + 1] & 0b11110000)==0)) // Right
	    {
	      if (dir & 0b00000001) // If facing down, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00000100) >0)&&((board[CurrentRow - 1][CurrentCol] & 0b11110000)==0)) // Up
	    {
	      if (dir & 0b00000001) // If facing down, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 1x.
	      {
	        RightTurn();
	      }
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00001000) >0)&&((board[CurrentRow][CurrentCol - 1] & 0b11110000)==0)) // Left
	    {
	      if (dir & 0b00000001) // If facing down, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000010) //If facing right, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, do nothing.
	      {
          AdjBack();
	      }
	    }
	    else
	    {
	      BackOut = true;
	    }
	  }
  }
  while(Win)
  {
    {
      int IncDir = board[CurrentRow][CurrentCol] & 0b11110000;
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"WinDir: %d",IncDir);
      wait1Msec(100);
      if (IncDir==0b11110000) // Home Square; loss
      {

      }
      else if (IncDir==0b00010000) // If entered down, leave up.
      {
        if (dir & 0b00000001) // If facing down, turn Right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 1x.
	      {
	        RightTurn();
	      }
      }
      else if (IncDir==0b00100000) // If entered right, leave left.
      {
        if (dir & 0b00000001) // If facing down, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, do nothing.
	      {
          AdjBack();
	      }
      }
      else if (IncDir==0b01000000) // If entered up, leave down.
      {
        if (dir & 0b00000001) // If facing down, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn left 1x.
	      {
	        LeftTurn();
	      }
      }
      else if (IncDir==0b10000000) // If entered left, leave right.
      {
        if (dir & 0b00000001) // If facing down, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
      }
    }
  }
}
