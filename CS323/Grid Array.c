#pragma config(Sensor, S1,     RightLight,          sensorLightActive)
#pragma config(Sensor, S2,     Touch,               sensorTouch)
#pragma config(Sensor, S4,     LeftLight,           sensorLightActive)
#pragma config(Motor,  motorA,          RightTire,     tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          LeftTire,      tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
This code is designed to allow a robot to find its way through a grid containing obstacles.
It is designed so that it will never explore previously explored blocks/directions unless it 
has reached a dead end or found the target block.  If the target block has been found, it will
return home using the shortest path known.
Author: Donovan Torgerson
Email: Donovan@Torgersonlabs.com

Directions:
00000001 = Down
00000010 = Right
00000100 = Up
00001000 = Left

128 64 32 16 8 4 2 1

*/

task WatchLight();
void NextSquare();

const int rowsize = 3;
const int columnsize = 4;
int RightRead = 100;
int LeftRead = 100;
int LeftSpeed= 20;
int RightSpeed= 20;
int MonitorTouch;
int dir = 0b00000001;
byte board[rowsize][columnsize];
int CurrentRow = 0;
int CurrentCol = 0;
int FutureRow = 1;
int FutureCol = 0;
bool BackOut = false;
bool Find = true;
bool Win = true;

task WatchLight()
{
 while(true)
 {
  RightRead = SensorValue[RightLight];
  LeftRead = (SensorValue[LeftLight] - 2);
  nxtDisplayClearTextLine(4);
  nxtDisplayTextLine(4,"R Eye: %d L Eye: %d",RightRead,LeftRead);
  wait1Msec(90);
 }
}

task WatchTires()
{
 int leftrotation = 0;
 int rightrotation = 0;
 bool up = true;
  while(true)
  {
   leftrotation = nMotorEncoder[LeftTire];
   rightrotation = nMotorEncoder[RightTire];
   nxtDisplayTextLine(2,"L: %d",leftrotation);
   nxtDisplayTextLine(3,"R: %d",rightrotation);
   wait1Msec(100);
  }
}

task WatchTouch()
{
  while (true)
  {
    MonitorTouch = SensorValue[Touch];
    nxtDisplayClearTextLine(7);
    nxtDisplayTextLine(7,"Touch: %d",MonitorTouch);
    wait1Msec(100);
  }
}

task WatchDirection() // Display current direction.
{
  while (true)
  {
    if (dir == 0b00000001)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Down");
    }
    else if (dir == 0b00000010)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Right");
    }
    else if (dir == 0b00000100)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Up");
    }
    else if (dir == 0b00001000)
    {
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"Dir: Left");
    }
  }
}

task DisplayLoc() // Display array location.
{
    while (true)
  {
    nxtDisplayClearTextLine(1);
    nxtDisplayClearTextLine(5);
    nxtDisplayTextLine(1,"r: %d c: %d",CurrentRow,CurrentCol);
    nxtDisplayTextLine(5,"fr: %d fc: %d",FutureRow,FutureCol);
    wait1Msec(100);
  }
}

void AdjustLeft()
{
  motor[RightTire] = -10;
  motor[LeftTire] = 20;
  while(RightRead < LeftRead);
  motor[RightTire] = 0;
  motor[LeftTire] = 0;
}

void AdjustRight()
{
  motor[RightTire] = 20;
  motor[LeftTire] = -10;
  while(LeftRead < RightRead);
  motor[RightTire] = 0;
  motor[LeftTire] = 0;
}

void CurrentLoc() // Calculate current location
{
  if (dir & 0b00000001)
  {
    CurrentRow += 1;
    FutureRow = CurrentRow + 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00000010)
  {
    CurrentCol += 1;
    FutureRow = CurrentRow;
    FutureCol = CurrentCol + 1;
  }
  else if (dir & 0b00000100)
  {
    CurrentRow -= 1;
    FutureRow = CurrentRow - 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00001000)
  {
    CurrentCol -= 1;
    FutureRow = CurrentRow;
    FutureCol = CurrentCol - 1;
  }
  if (FutureRow <0 || FutureCol <0)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
  if (FutureRow >= rowsize || FutureCol >= columnsize)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
}

void LocTurn() // Calculate direction after a turn.
{
  if (dir & 0b00000001)
  {
    FutureRow = CurrentRow + 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00000010)
  {
    FutureRow = CurrentRow;
    FutureCol = CurrentCol + 1;
  }
  else if (dir & 0b00000100)
  {
    FutureRow = CurrentRow - 1;
    FutureCol = CurrentCol;
  }
  else if (dir & 0b00001000)
  {
    FutureRow = CurrentRow;
    FutureCol = CurrentCol - 1;
  }
  if (FutureRow <0 || FutureCol <0)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
  if (FutureRow >= rowsize || FutureCol >= columnsize)
  {
    FutureRow = 0;
    FutureCol = 0;
  }
}

void LeftTurn() // Left turn code
 {
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  nMotorEncoder[LeftTire] = 0;
  nMotorEncoder[RightTire] = 0;
  motor[LeftTire] = -20;
  motor[RightTire] = 20;
  while(nMotorEncoder[RightTire] < 520);
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  if (dir == 0b00001000)
  {
    dir = 0b00000001;
  }
  else
  {
    dir = dir << 1;
  }
  LocTurn();
 }

void RightTurn() // Right turn code
 {
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  nMotorEncoder[LeftTire] = 0;
  nMotorEncoder[RightTire] = 0;
  motor[LeftTire] = 20;
  motor[RightTire] = -20;
  while(nMotorEncoder[LeftTire] < 520);
  motor[LeftTire] = 0;
  motor[RightTire] = 0;
  nMotorEncoder[RightTire] = 0;
  nMotorEncoder[LeftTire] = 0;
  if (dir == 0b00000001)
    {
      dir = 0b00001000;
    }
  else
    {
      dir = dir >> 1;
    }
  LocTurn();
 }

void LineAdjust() // Adjust to line and check for wall.
  {
    bool go = true;
    while (go)
    {
	    motor[RightTire] = 20;
	    motor[LeftTire] = 20;
	    if (MonitorTouch > 0)
       {
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         nMotorEncoder[LeftTire] = 0;
         nMotorEncoder[RightTire] = 0;
         motor[RightTire] = -15;
         motor[LeftTire] = -15;
         while(nMotorEncoder[RightTire] > -200);
         nMotorEncoder[LeftTire] = 0;
         nMotorEncoder[RightTire] = 0;
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         board[CurrentRow][CurrentCol] ^= dir;
         wait1Msec(5000);
         go = false;
	      }
	    else if (RightRead < 43 || LeftRead < 43)
	    {
	     if (MonitorTouch > 0)
        {
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         wait1Msec(5000);
        }
	     else if (abs(RightRead - LeftRead) < 6)
	      {
	        motor[RightTire] = 0;
	        motor[LeftTire] = 0;
	        go = false;
	        wait1Msec(1000);
	        NextSquare();
	      }
	     else if (RightRead < (LeftRead - 6))
	      {
	        AdjustLeft();
	      }
	     else if (LeftRead < (RightRead - 6))
	      {
          AdjustRight();
        }
      }
    }
  }

void AdjBack()
{
    bool go = true;
    while (go)
    {
	    motor[RightTire] = 20;
	    motor[LeftTire] = 20;
	    if (RightRead < 43 || LeftRead < 43)
	    {
	     if (abs(RightRead - LeftRead) < 6)
	     {
	       motor[RightTire] = 0;
	       motor[LeftTire] = 0;
	       go = false;
	       wait1Msec(1000);
	       nMotorEncoder[LeftTire] = 0;
         nMotorEncoder[RightTire] = 0;
         motor[RightTire] = 20;
         motor[LeftTire] = 20;
         while(nMotorEncoder[RightTire] < 830);
         motor[RightTire] = 0;
         motor[LeftTire] = 0;
         CurrentLoc();
         BackOut = false;
	     }
	     else if (RightRead < (LeftRead - 6))
	     {
	       AdjustLeft();
	     }
	     else if (LeftRead < (RightRead - 6))
	     {
         AdjustRight();
       }
     }
   }
 }

void NextSquare() // Move to next square and run CurrentLoc.
{
  board[CurrentRow][CurrentCol] ^= dir;
  nMotorEncoder[LeftTire] = 0;
  nMotorEncoder[RightTire] = 0;
  motor[RightTire] = 20;
  motor[LeftTire] = 20;
  while(nMotorEncoder[RightTire] < 830);
  motor[RightTire] = 0;
  motor[LeftTire] = 0;
  if (RightRead < 43 || LeftRead < 43)
  {
    nVolume = 3;
    PlaySound(soundUpwardTones);
    RightTurn();
    RightTurn();
    nMotorEncoder[LeftTire] = 0;
    nMotorEncoder[RightTire] = 0;
    motor[RightTire] = 20;
    motor[LeftTire] = 20;
    while(nMotorEncoder[RightTire] < 830);
    motor[RightTire] = 0;
    motor[LeftTire] = 0;
    Find = false;
  }
  else
  {
    CurrentLoc();
    board[CurrentRow][CurrentCol] = board[CurrentRow][CurrentCol] | (dir <<4);
  }
  wait1Msec(2000);
}

task main()
{
  StartTask(WatchTires);
  wait1Msec(90);
  StartTask(WatchLight);
  wait1Msec(90);
  StartTask(WatchTouch);
  wait1Msec(90);
//  StartTask(WatchDirection);
//  wait1Msec(90);
  StartTask(DisplayLoc);
  wait1Msec(90);
  for (int r=0;r<rowsize;r++)
  {
    for (int c=0;c<columnsize;c++)
    {
      board[r][c] = 0b00001111;
      if (r==0) board[r][c]^=0b00000100;
      if (r==rowsize-1) board[r][c]^=0b00000001;
      if (c==0) board[r][c]^=0b00001000;
      if (c==columnsize-1) board[r][c]^=0b00000010;
    }
  }
  board[0][0] = board[0][0] | 0b11110000;
//  LeftTurn();
//  motor[RightTire]=LeftSpeed;
//  motor[LeftTire]=RightSpeed;
//  board[CurrentRow][CurrentCol] = 0b00001000;
//  dir = 0b00001000;
  while(Find)
  {
    if (BackOut)
    {
      int IncDir = board[CurrentRow][CurrentCol] & 0b11110000;
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"IncDir: %d",IncDir);
      wait1Msec(100);
      if (IncDir==0b11110000) // Home Square; loss
      {
        nVolume = 3;
        PlaySound(soundLowBuzz);
        wait1Msec(1000);
        Find = false;
        Win = false;
      }
      else if (IncDir==0b00010000) // If entered down, leave up.
      {
        if (dir & 0b00000001) // If facing down, turn Right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 1x.
	      {
	        RightTurn();
	      }
      }
      else if (IncDir==0b00100000) // If entered right, leave left.
      {
        if (dir & 0b00000001) // If facing down, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, do nothing.
	      {
          AdjBack();
	      }
      }
      else if (IncDir==0b01000000) // If entered up, leave down.
      {
        if (dir & 0b00000001) // If facing down, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn left 1x.
	      {
	        LeftTurn();
	      }
      }
      else if (IncDir==0b10000000) // If entered left, leave right.
      {
        if (dir & 0b00000001) // If facing down, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
      }
    }
    else
    {
	    if (((board[CurrentRow][CurrentCol] & dir) >0)&&((board[FutureRow][FutureCol] & 0b11110000)==0))
	    {
	      LineAdjust();
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00000001) >0)&&((board[CurrentRow +1][CurrentCol] & 0b11110000)==0)) // Down
	    {
	      if (dir & 0b00000001) // If facing down, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn left 1x.
	      {
	        LeftTurn();
	      }
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00000010) >0)&&((board[CurrentRow][CurrentCol + 1] & 0b11110000)==0)) // Right
	    {
	      if (dir & 0b00000001) // If facing down, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00000100) >0)&&((board[CurrentRow - 1][CurrentCol] & 0b11110000)==0)) // Up
	    {
	      if (dir & 0b00000001) // If facing down, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 1x.
	      {
	        RightTurn();
	      }
	    }
	    else if (((board[CurrentRow][CurrentCol] & 0b00001000) >0)&&((board[CurrentRow][CurrentCol - 1] & 0b11110000)==0)) // Left
	    {
	      if (dir & 0b00000001) // If facing down, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000010) //If facing right, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, do nothing.
	      {
          AdjBack();
	      }
	    }
	    else
	    {
	      BackOut = true;
	    }
	  }
  }
  while(Win)
  {
    {
      int IncDir = board[CurrentRow][CurrentCol] & 0b11110000;
      nxtDisplayClearTextLine(6);
      nxtDisplayTextLine(6,"WinDir: %d",IncDir);
      wait1Msec(100);
      if (IncDir==0b11110000) // Home Square; loss
      {

      }
      else if (IncDir==0b00010000) // If entered down, leave up.
      {
        if (dir & 0b00000001) // If facing down, turn Right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 1x.
	      {
	        RightTurn();
	      }
      }
      else if (IncDir==0b00100000) // If entered right, leave left.
      {
        if (dir & 0b00000001) // If facing down, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, do nothing.
	      {
          AdjBack();
	      }
      }
      else if (IncDir==0b01000000) // If entered up, leave down.
      {
        if (dir & 0b00000001) // If facing down, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000010) // If facing right, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn left 1x.
	      {
	        LeftTurn();
	      }
      }
      else if (IncDir==0b10000000) // If entered left, leave right.
      {
        if (dir & 0b00000001) // If facing down, turn left 1x.
	      {
	        LeftTurn();
	      }
	      else if (dir & 0b00000010) // If facing right, do nothing.
	      {
          AdjBack();
	      }
	      else if (dir & 0b00000100) // If facing up, turn right 1x.
	      {
	        RightTurn();
	      }
	      else if (dir & 0b00001000) // If facing left, turn right 2x.
	      {
	        RightTurn();
	        RightTurn();
	      }
      }
    }
  }
}
